# Æternity consensus protocol (27f63c2d43752a68d09a83666f6a00bef7d2f1f2)

This document defines the Æternity consensus protocol.

## Introduction

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

## Notation

- `x || y`, x concatenated with y
- `sk <- rand(1^n)`, sample a random n bit number

## Overview

### Blockchain

A blockchain is a specific instance of a distributed ledger made up from blocks, which are
arranged  as a tree with the root of the tree being the `genesis block`. Each node in this
tree has exactly one `parent` but can have multiple children. Blocks specify their parent
via the `prev_hash` field in the block header, with the genesis block having a `prev_hash`
of all `0`.

At any point, the `block height` is the distance from the current valid `top` block to the
genesis block. The genesis block has height zero.
A valid block here means valid according to the consensus rules described below.
In order to find the best valid chain given a tree of blocks, every node operator in the
network sums the amount of work (see Proof of Work) done on each chain. The best valid
chain is then the chain that has the most work done. Any ties here will be resolved by
the time a block was received at, i.e. it will prefer the block it received first.

### Blocks

A block is a collection of transactions and associated metadata. Blocks are generated by
miners and new coins can only be created via these new blocks.

(***TODO:*** Add mining reward schedule)

#### Genesis block

The genesis block is special in the sense that it does not have a parent, no coinbase
transaction and contains the initial state of the Æternity blockchain. The initial state
is generated from the distribution of the AETernity ERC20 token on the Ethereum blockchain
at a given cut-off point.

### Transactions

Æternity follows the "fat protocol" approach, which means that the protocol itself
has many features built in, as opposed to e.g. Ethereum, which maps any functionality beyond
basic transactions—which change the state of an account—to smart contracts.

#### Coinbase transactions

(***TODO***: is there any benefit/reason to have a coinbase transaction with an account model?)

### Proof of Work

[Cuckoo Cycle](https://github.com/tromp/cuckoo) is the algorithm used for proof of work.
It was designed to prevent the dynamics that have developed in bitcoin and similar systems, where
the mining operations are dominated by special purpose hardware. Thus mining should be viable on
general purpose, commodity hardware while consuming less power than the alternatives. The problem
being solved is that of finding cycles in a bipartite graph.

### Accounts

### P2P network

The peer-to-peer network is not part of the consensus and will be described in a
separate document.

### Coins and tokens

#### Aeons

Aeon is the main coin used in the Æternity system. We use the following denominations:

```
1
1_000
1_000_000
1_000_000_000
1_000_000_000_000
1_000_000_000_000_000
1_000_000_000_000_000_000 | aeon
```

## Specification

### Crypto

Blake2b (256 bits digest) and secp256k1

#### Keys

KeyGen

```
n = 256
sk <- rand(1^n)
pk <- g^sk
```

Erlang returns `pk` as an uncompressed secp256k1 curve point.

Binary representation:

```
sk_bin <- sk
pk_bin <- 00000100 || pk_x || pk_y
```

The public key is `0x04` concatenated with the x and then the y coordinate of the point. Thus making it 65 bytes long.

#### Signatures

ECDSA, DER encoding (~72 bytes in size)

## Accounts

```
address: public key
balance:
nonce:
height:
```

### Blocks

```
PROTOCOL_VERSION: 2
GENESIS_VERSION: 2
```

- the timestamp of a block MUST be smaller than `now() + 30m`
- the version MUST match the `PROTOCOL_VERSION`
- the `pow_evidence` MUST be valid
- MUST have `0 <= nonce <= MAX_NONCE`
- txs_hash MUST be correct root hash of the merkle tree of all transactions.
- ***TODO***: fill in missing rules


```
 Fieldname       Size (bytes)
 -------------- ------
| height       | 8    |
 -------------- ------
| prev_hash    | 32   |
 -------------- ------
| root_hash    | 32   |
 -------------- ------
| trees        |      |
 -------------- ------
| txs_hash     | 32   |
 -------------- ------
| txs          | var  |
 -------------- ------
| target       | 8    |
 -------------- ------
| nonce        | 8    |
 -------------- ------
| time         | 8    |
 -------------- ------
| version      | 8    |
 -------------- ------
| pow_evidence | 168  |
 -------------- ------
```

#### Block header

```
 Fieldname       Size (bytes)
 -------------- ------
| height       | 8    |
 -------------- ------
| prev_hash    | 32   |
 -------------- ------
| txs_hash     | 32   |
 -------------- ------
| root_hash    | 32   |
 -------------- ------
| target       | 8    |
 -------------- ------
| nonce        | 8    |
 -------------- ------
| time         | 8    |
 -------------- ------
| version      | 8    |
 -------------- ------
| pow_evidence | 168  |
 -------------- ------
```

(***TODO: Why do different fields have different positions?***)

### Transactions


#### Signed transaction

```
 Fieldname       Size (bytes)
 -------------- -----
| data         | var |
 -------------- -----
| signatures   | var |
 -------------- -----
```

MUST have valid signature from private key belonging to `sender`.


#### Coinbase

```
 Fieldname       Size (bytes)
 -------------- -----
| account      | 65  |
 -------------- -----
```

There MUST be one coinbase transaction per block.

#### Spend

```
 Fieldname       Size (bytes)
 -------------- -----
| sender       | 65  |
 -------------- -----
| recipient    | 65  |
 -------------- -----
| amount       | 8   |
 -------------- -----
| fee          | 8   |
 -------------- -----
| nonce        | 8   |
 -------------- -----
```

Fee MUST be at least `1` aeon.

### Proof of Work

```
HIGHEST_TARGET_SCI: 0x2100ffff
HIGHEST_TARGET_INT: 0xffff000000000000000000000000000000000000000000000000000000000000
NONCE_BITS: 64
MAX_NONCE: 0xffffffffffffffff
EXPECTED_BLOCK_MINE_RATE: 60 * 5 # every 5 minutes
RECALCULATE_DIFFICULTY_FREQUENCY: 10
```

[Cuckoo cycle](https://github.com/tromp/cuckoo) is used as the proof of work
algorithm. Solutions take the form of arrays length `l`, where `l` is the length
(`PROOFSIZE`) of the cycle in the bipartite graph. The size of the graph is denoted
by [`the 2-log of the graph size, which is the size in bits of the node identifiers`](https://github.com/tromp/cuckoo/blob/488c03f5dbbfdac6d2d3a7e1d0746c9a7dafc48f/src/cuckoo.h#L11) `EDGEBITS`. The difficulty
of a graph with `M` nodes and `N` edges is based on the ratio `M/N`, with the standard
implementation being fixed at `M/N = 1/2`. Please refer to the [whitepaper](https://github.com/tromp/cuckoo/blob/master/doc/cuckoo.pdf?raw=true) for more details. These indices are refered to as `micrononces`, not
to be confused with the nonce included in the header itself.
This graph is generated by hashing every edge `i in (0..N)` twice with a keyed hash
function `h` ([SipHash](https://131002.net/siphash/)). The `key` used for these operations
is the hash of a block header plus a nonce. The first node belonging to every edge is
given by hashing `h(key, index*2)` and the second by `h(key, index*2+1)`.

Current defaults:

```
PROOFSIZE: 42
EDGEBITS: 28
```


```
header = version || height || prev_hash || txs_hash || root_hash || target || evidence || nonce || time
           64         64         256         256          256         64       42*32       64       64
```

```
h_header = Blake2b(header)
```

The default `key` for cuckoo is 80 bytes long. The `nonce` here is expressed
in little-endian notation, to keep consistent with cuckoo cycle, which does
the same.

```
key = h_header || nonce || 0..0
        256        64      192
```


A valid solution MUST:

- be encoded according to the solution encoding rules
- form a cycle (***TODO: make this more precise***)
- only contain `micrononces < 2^EDGEBITS - 1`
- have micrononces in ascending order
- pass the difficulty check


#### Solution Encoding Rules

Since `EDGEBITS <= 32`, we can encode an edge as a 32bit integer, otherwise
it would have to be 64 bits. Therefore a solution is currently `[u32; 42]`.


#### Difficulty target

See [Chapter 9 of the cuckoo cycle paper](https://github.com/tromp/cuckoo/blob/master/doc/cuckoo.pdf?raw=true):

	For further control, a difficulty target 0 < T < 2^256 is introduced, and we impose the additional
constraint that the Blake2b 256 bit digest of the cycle nonces in ascending order be less than T, thus reducing
the success probability by a factor 2^256 .

Thus we adopt the target notion from Bitcoin and also use the same way to
express it.

The target thershold relates to another value: the difficulty. This is
proportional to the hardness of the PoW task:

```
difficulty = <target of difficulty 1> / target
```

a floating point value.
Bitcoin uses `0x00000000FFFF0000000000000000000000000000000000000000000000000000`
as Difficulty 1 target (`0x1d00ffff` in scientific notation, see below). For
Cuckoo Cycle we need a lighter filtering of solutions than for SHA-256 as the
basic algorithm is much slower than a simple hash generation, so we use the
largest possible value: `0xFFFF000000000000000000000000000000000000000000000000000000000000`
(`0x2100ffff` in scientific notation) as difficulty 1.

We store the current target threshold in the block header in scientific notation.
Difficulty is used to select the winning fork of new blocks: the difficulty of a
chain of blocks is the sum of the diffculty of each block.

Integers represented in scientific notation:
`2^24 * <base-2 exponent + 3> + the first 3 most significant bytes` (i.e.,
the [significand](https://en.wikipedia.org/wiki/Significand)).
The + 3 corresponds to the length of the
significand (i.e., the int value is `0.<significand> * 8^<exponent>`).
https://en.bitcoin.it/wiki/Difficulty#How_is_difficulty_stored_in_blocks.3F)


#### Target adjustment

Some concepts:

```
Difficulty = HIGHEST_TARGET / Target
Rate       = Capacity / Difficulty  (blocks/ms)
Capacity   = number of potential solutions per ms generated by miners

DesiredTimeBetweenBlocks = aec_governance:expected_block_mine_rate()
DesiredRate              = 1 / DesiredTimeBetweenBlocks
```

The basic idea of the algorithm is to estimate the current network capacity
based on the `N` (= 10) previous blocks and use that to set the new
target:

```
NewDifficulty = EstimatedCapacity / DesiredRate
NewTarget     = HIGHEST_TARGET / NewDifficulty
              = HIGHEST_TARGET * DesiredRate / EstimatedCapacity
```

We can estimate the network capacity used to mine a given block `i` as

```
EstimatedCapacity[i] = Difficulty[i] / MiningTime[i]
MiningTime[i]        = Time[i + 1] - Time[i]
```

The estimated capacity across all `N` blocks is then the weighted (by time)
average of the estimated capacities for each block.

```
EstimatedCapacity = Sum(EstimatedCapacity[i] * MiningTime[i]) / TotalTime
                  = Sum(Difficulty[i]) / TotalTime
                  = Sum(HIGHEST_TARGET / Target[i]) / TotalTime
```

Now, the problem is that we can't do any floating point arithmetic (to
ensure the calculation can be verified by other nodes), so we pick a
reasonably big integer K (= HIGHEST_TARGET * 2^32) and compute

```
EstimatedCapacity ≈ Sum(K * HIGHEST_TARGET div Target[i]) / TotalTime / K
```

Then

```
NewTarget = HIGHEST_TARGET * DesiredRate / EstimatedCapacity
          ≈ HIGHEST_TARGET * DesiredRate * TotalTime * K / Sum(K * HIGHEST_TARGET div Target[i])
          ≈ DesiredRate * TotalTime * K / Sum(K div Target[i])
          ≈ TotalTime * K div (DesiredTimeBetweenBlocks * Sum(K div Target[i]))
```

